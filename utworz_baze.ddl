-- Generated by Oracle SQL Developer Data Modeler 18.3.0.268.1156
--   at:        2020-09-02 12:56:40 CEST
--   site:      Oracle Database 11g
--   type:      Oracle Database 11g



CREATE TABLE badania_rynku (
    id_badania_rynku           NUMBER(6) NOT NULL,
    numer_rundy                NUMBER(5) NOT NULL,
    his_zakupow_liczba_rund    NUMBER(5) DEFAULT 0 NOT NULL,
    id_marki                   NUMBER(6) NOT NULL,
    id_grupy_konsumentow       NUMBER(5) NOT NULL,
    koszt_badania_rynku        NUMBER(15) NOT NULL,
    uwzglednic_jakosc          CHAR(1 CHAR) DEFAULT 'n' NOT NULL,
    uwzglednic_cene            CHAR(1 CHAR) DEFAULT 'n' NOT NULL,
    uwzglednic_his_zakupow     CHAR(1 CHAR) DEFAULT 'n' NOT NULL,
    uwzglednic_marketing       CHAR(1 CHAR) DEFAULT 'n' NOT NULL,
    uwzg_marketing_ost_runda   CHAR(1 CHAR) DEFAULT 'n' NOT NULL
);

ALTER TABLE badania_rynku
    ADD CHECK ( uwzglednic_jakosc IN (
        'n',
        't'
    ) );

ALTER TABLE badania_rynku
    ADD CHECK ( uwzglednic_cene IN (
        'n',
        't'
    ) );

ALTER TABLE badania_rynku
    ADD CHECK ( uwzglednic_his_zakupow IN (
        'n',
        't'
    ) );

ALTER TABLE badania_rynku
    ADD CHECK ( uwzglednic_marketing IN (
        'n',
        't'
    ) );

ALTER TABLE badania_rynku
    ADD CHECK ( uwzg_marketing_ost_runda IN (
        'n',
        't'
    ) );

COMMENT ON COLUMN badania_rynku.his_zakupow_liczba_rund IS
    'Z ilu rund producent poznal historie zakupow konsumentow.';

COMMENT ON COLUMN badania_rynku.id_grupy_konsumentow IS
    'Wskazana przez producenta grupa konsumentow, ktorej dotyczylo badanie rynku.';

COMMENT ON COLUMN badania_rynku.koszt_badania_rynku IS
    'Calkowity koszt jaki poniosl producent w wyniku realizacji tego badania rynku. Przechowywanie tej wartosci wynika z faktu, ze stawki przeprowadzanie badania rynku dla poszczegolnych grup konsumentow moga ulegac zmianom.'
    ;

COMMENT ON COLUMN badania_rynku.uwzglednic_jakosc IS
    'Czy podczas badania uwzgledniane bylo kryterium jakosci.';

COMMENT ON COLUMN badania_rynku.uwzglednic_cene IS
    'Czy podczas badania uwzgledniane bylo kryterium ceny.';

COMMENT ON COLUMN badania_rynku.uwzglednic_his_zakupow IS
    'Czy podczas badania uwzgledniane bylo kryterium przywiazania do marki realizowane jako historia zakupow konsumenta z ostatnich szesciu rund.'
    ;

COMMENT ON COLUMN badania_rynku.uwzglednic_marketing IS
    'Czy podczas badania uwzgledniane bylo kryterium marketingu z ostatnich szesciu rund.';

COMMENT ON COLUMN badania_rynku.uwzg_marketing_ost_runda IS
    'Czy podczas badania uwzgledniane bylo kryterium marketingu z ostatniej rundy.';

CREATE INDEX badania_rynku_nry_rund_fk_idx ON
    badania_rynku (
        numer_rundy
    ASC );

CREATE INDEX badania_rynku_marki_fk_idx ON
    badania_rynku (
        id_marki
    ASC );

CREATE INDEX badania_rynku_gr_kons_fk_idx ON
    badania_rynku (
        id_grupy_konsumentow
    ASC );

ALTER TABLE badania_rynku ADD CONSTRAINT badania_rynku_pk PRIMARY KEY ( id_badania_rynku );

CREATE TABLE dostepy_producentow_his_zakup (
    id_konsumenta      NUMBER(10) NOT NULL,
    numer_rundy        NUMBER(5) NOT NULL,
    id_badania_rynku   NUMBER(6) NOT NULL
);

CREATE INDEX dost_prod_badania_rynku_fk_idx ON
    dostepy_producentow_his_zakup (
        id_badania_rynku
    ASC );

ALTER TABLE dostepy_producentow_his_zakup
    ADD CONSTRAINT dost_producentow_his_zakup_pk PRIMARY KEY ( id_konsumenta,
                                                               numer_rundy,
                                                               id_badania_rynku );

CREATE TABLE grupy_konsumentow (
    id_grupy_konsumentow         NUMBER(5) NOT NULL,
    koszt_uzyskania_ocen         NUMBER(10) NOT NULL,
    koszt_his_zakup_jedna_tura   NUMBER(10) NOT NULL,
    opis                         VARCHAR2(200 CHAR)
);

COMMENT ON COLUMN grupy_konsumentow.koszt_uzyskania_ocen IS
    'Koszt uzyskania ocen wskazanej marki od WSZYSTKICH konsumentow nalezacych do danej grupy.';

COMMENT ON COLUMN grupy_konsumentow.koszt_his_zakup_jedna_tura IS
    'Koszt uzyskania historii zakupï¿½w z jedej rundy od WSZYSTKICH konsumentow nalezacych do danej grupy.';

COMMENT ON COLUMN grupy_konsumentow.opis IS
    'Jesli grupa konsumentow zostala stworzona wg okreslonych regul, to powinny byc one zawarte w tym polu w celu ulatwienia graczom wyboru odpowiedniej grupy docelowej podczas badania rynku'
    ;

ALTER TABLE grupy_konsumentow ADD CONSTRAINT grupy_konsumentow_pk PRIMARY KEY ( id_grupy_konsumentow );

CREATE TABLE historie_cen (
    cena          NUMBER(8) NOT NULL,
    id_marki      NUMBER(6) NOT NULL,
    numer_rundy   NUMBER(5) NOT NULL
);

CREATE INDEX historie_cen_nry_rund_fk_idx ON
    historie_cen (
        numer_rundy
    ASC );

ALTER TABLE historie_cen ADD CONSTRAINT historie_cen_pk PRIMARY KEY ( id_marki,
                                                                      numer_rundy );

CREATE TABLE jakosci_marek (
    jakosc_marki                 NUMBER(2) NOT NULL,
    ref_koszt_produkcji_sztuki   NUMBER(8) NOT NULL
);

COMMENT ON COLUMN jakosci_marek.jakosc_marki IS
    'Poziom jakosci marki - liczba naturalna okreslajaca w sposob umowny jakosc produktu pewnej marki. Im wieksza liczba, tym wyzsza jakosc.'
    ;

COMMENT ON COLUMN jakosci_marek.ref_koszt_produkcji_sztuki IS
    'Referencyjny koszt produkcji sztuki produktu marki, ktory jest przypisywany jako koszt produkcji tworzonej marce o okrelonej jakosci.'
    ;

ALTER TABLE jakosci_marek ADD CONSTRAINT jakosci_marek_pk PRIMARY KEY ( jakosc_marki );

CREATE TABLE konsumenci (
    id_konsumenta                   NUMBER(10) NOT NULL,
    cena_poziom_aspiracji           NUMBER(5) NOT NULL,
    cena_poziom_rezerwacji          NUMBER(5) NOT NULL,
    jakosc_poziom_aspiracji         NUMBER(2) NOT NULL,
    jakosc_poziom_rezerwacji        NUMBER(2) NOT NULL,
    his_zakupow_poziom_aspiracji    NUMBER(3, 2) NOT NULL,
    his_zakupow_poziom_rezerwacji   NUMBER(3, 2) NOT NULL,
    marketing_poziom_aspiracji      NUMBER(3) NOT NULL,
    marketing_poziom_rezerwacji     NUMBER(3) NOT NULL
);

ALTER TABLE konsumenci ADD CONSTRAINT konsumenci_pk PRIMARY KEY ( id_konsumenta );

CREATE TABLE koszty_magazynowania (
    sposob_naliczania_kosztow_mag   CHAR(1 CHAR) NOT NULL,
    koszt_mag_sztuki_lub_magazynu   NUMBER(8) NOT NULL,
    wielkosc_powierzchni_mag        NUMBER(6),
    upust_za_kolejny_magazyn        NUMBER(2),
    id_producenta                   NUMBER(3) NOT NULL,
    numer_rundy                     NUMBER(5) NOT NULL
);

COMMENT ON COLUMN koszty_magazynowania.sposob_naliczania_kosztow_mag IS
    'Sposob naliczania kosztow magazynowania produktow danego producenta  obowiazujacy od danej rundy.';

COMMENT ON COLUMN koszty_magazynowania.koszt_mag_sztuki_lub_magazynu IS
    'Koszt zmagazynowania jednej sztuki produktu (niezaleznie od jakosci marki) lub wynajecia przestrzeni magazynowej (jesli obowiazuje sposob naliczania kosztow magazynowania oparty na przestrzeniach magazynowych) przypisany danemu producentowi i obowiazujacy od danej rundy.'
    ;

COMMENT ON COLUMN koszty_magazynowania.wielkosc_powierzchni_mag IS
    'Wielkosci powierzchni magazynowej liczona w sztukach produktu, obowiazujaca od danej rundy, za ktora bedzie musial zaplacic dany producent jesli bedzie musial zmagazynowac jakies produkty.'
    ;

COMMENT ON COLUMN koszty_magazynowania.upust_za_kolejny_magazyn IS
    'Upust za kazda (poza pierwsza) wynajeta przestrzen magazynowa przypisany danemu producentowi i obowiazujacy od danej rundy.'
    ;

CREATE INDEX koszty_magazyn_nr_rundy_idx ON
    koszty_magazynowania (
        numer_rundy
    DESC );

ALTER TABLE koszty_magazynowania ADD CONSTRAINT koszty_magazynowania_pk PRIMARY KEY ( id_producenta,
                                                                                      numer_rundy );

CREATE TABLE koszty_marketingu (
    koszt_bazowy          NUMBER(8) NOT NULL,
    koszt_per_st_intens   NUMBER(8) NOT NULL,
    numer_rundy           NUMBER(5) NOT NULL,
    id_producenta         NUMBER(3) NOT NULL
);

COMMENT ON COLUMN koszty_marketingu.koszt_bazowy IS
    'Bazowy koszt marketingu przypisany konkretnemu producentowi obowiazujacy od danej rundy.';

COMMENT ON COLUMN koszty_marketingu.koszt_per_st_intens IS
    'Koszt za kazdy stopien intensywnosci  marketingu przypisany konkretnemu producentowi obowiazujacy od danej rundy.';

CREATE INDEX koszty_marketingu_nr_rundy_idx ON
    koszty_marketingu (
        numer_rundy
    DESC );

ALTER TABLE koszty_marketingu ADD CONSTRAINT koszty_marketingu_pk PRIMARY KEY ( id_producenta,
                                                                                numer_rundy );

CREATE TABLE koszty_produkcji_produktow (
    id_marki          NUMBER(6) NOT NULL,
    koszt_produkcji   NUMBER(8) NOT NULL,
    numer_rundy       NUMBER(5) NOT NULL
);

COMMENT ON COLUMN koszty_produkcji_produktow.koszt_produkcji IS
    'Koszt produkcji jednej sztuki produktu obowiazujacy od danej rundy.';

CREATE INDEX koszty_produkcji_nr_rundy_idx ON
    koszty_produkcji_produktow (
        numer_rundy
    DESC );

ALTER TABLE koszty_produkcji_produktow ADD CONSTRAINT koszty_produkcji_produktow_pk PRIMARY KEY ( id_marki,
                                                                                                  numer_rundy );

CREATE TABLE magazynowania (
    wolumen       NUMBER(8) NOT NULL,
    numer_rundy   NUMBER(5) NOT NULL,
    id_marki      NUMBER(6) NOT NULL
);

COMMENT ON COLUMN magazynowania.wolumen IS
    'Zmagazynowany wolumen.';

CREATE INDEX magazynowania_nry_rund_fk_idx ON
    magazynowania (
        numer_rundy
    ASC );

ALTER TABLE magazynowania ADD CONSTRAINT magazynowania_pk PRIMARY KEY ( id_marki,
                                                                        numer_rundy );

CREATE TABLE marketingi (
    id_marketingu             NUMBER(12) NOT NULL,
    numer_rundy               NUMBER(5) NOT NULL,
    intensywnosc_marketingu   NUMBER(3) DEFAULT 1 NOT NULL,
    id_marki                  NUMBER(6) NOT NULL
);

ALTER TABLE marketingi ADD CHECK ( intensywnosc_marketingu BETWEEN 1 AND 100 );

COMMENT ON COLUMN marketingi.intensywnosc_marketingu IS
    'Okresla, jak intensywna ma byc kampania marketingowa, to znaczy ile i jakie reklamy zobacza konsumenci, a w konsekwencji jak duzy wplyw zostanie na nich wywarty.Przyjmuje wartosci od 1 do 100.'
    ;

CREATE INDEX marketingi_nry_rund_fk_idx ON
    marketingi (
        numer_rundy
    ASC );

CREATE INDEX marketingi_marki_fk_idx ON
    marketingi (
        id_marki
    ASC );

ALTER TABLE marketingi ADD CONSTRAINT marketingi_pk PRIMARY KEY ( id_marketingu );

CREATE TABLE marki (
    id_marki                NUMBER(6) NOT NULL,
    id_producenta           NUMBER(3) NOT NULL,
    nazwa_marki             VARCHAR2(20 CHAR) NOT NULL,
    jakosc_marki            NUMBER(2) NOT NULL,
    koszt_utworzenia        NUMBER(8) NOT NULL,
    runda_utworzenia        NUMBER(3) NOT NULL,
    cena_za_sztuke          NUMBER(8) NOT NULL,
    aktualna_liczba_sztuk   NUMBER(15) DEFAULT 0 NOT NULL
);

COMMENT ON COLUMN marki.nazwa_marki IS
    'Musi byc unikalna w skali calej rozgrywki.';

COMMENT ON COLUMN marki.jakosc_marki IS
    'Wybrany poziom jakosci marki. Nie moze byc zmodyfikowany.';

COMMENT ON COLUMN marki.koszt_utworzenia IS
    'Koszt jaki poniosl konsument w wyniku wprowadzenia tej marki na rynek. Przechowywanie tej wartosci wynika z faktu, ze w trakcie rozgrywki koszt uprowadzenia nowej marki na rynek moze ulegac zmianom'
    ;

COMMENT ON COLUMN marki.runda_utworzenia IS
    'Runda, w ktorej zostala utworzona marka.';

COMMENT ON COLUMN marki.cena_za_sztuke IS
    'Aktualna cena za sztuke produktu danej marki.';

COMMENT ON COLUMN marki.aktualna_liczba_sztuk IS
    'Aktualnie wyprodukowana liczba sztuk produktu danej marki, ktora bedzie oferowana konsumentom w trakcie zakupow na koniec rundy.'
    ;

CREATE INDEX marki_producenci_fk_idx ON
    marki (
        id_producenta
    ASC );

CREATE INDEX marki_jakosci_marek_fk_idx ON
    marki (
        jakosc_marki
    ASC );

ALTER TABLE marki ADD CONSTRAINT marki_pk PRIMARY KEY ( id_marki );

ALTER TABLE marki ADD CONSTRAINT marki_nazwa_marki_un UNIQUE ( nazwa_marki );

CREATE TABLE numery_rund (
    numer_rundy   NUMBER(5) NOT NULL
);

ALTER TABLE numery_rund ADD CONSTRAINT numery_rund_pk PRIMARY KEY ( numer_rundy );

CREATE TABLE oceny_marek (
    id_konsumenta      NUMBER(10) NOT NULL,
    id_badania_rynku   NUMBER(6) NOT NULL,
    ocena              NUMBER(2) NOT NULL
);

COMMENT ON COLUMN oceny_marek.ocena IS
    'Ocena marki przez konsumenta; ma charakter porownawczy wzgledem pozostalych marek dostepnych na rynku. Przyjmuje minimalna wartosc rowna 1 jesli wskazana przez badajacego marka jest gorsza od wszystkich pozostalych marek dostepnych na rynku, natomiast maksymalna wartosc rowna 10 przyjmuje jesli wskazana marka jest lepsza od wszystkich pozostalych.'
    ;

CREATE INDEX oceny_marek_bad_rynku_fk_idx ON
    oceny_marek (
        id_badania_rynku
    ASC );

ALTER TABLE oceny_marek ADD CONSTRAINT oceny_marek_pk PRIMARY KEY ( id_konsumenta,
                                                                    id_badania_rynku );

CREATE TABLE producenci (
    id_producenta      NUMBER(3) NOT NULL,
    nazwa_producenta   VARCHAR2(30 CHAR) NOT NULL,
    fundusze           NUMBER(14) NOT NULL,
    czy_spasowal       CHAR(1 CHAR) DEFAULT 'n' NOT NULL
);

ALTER TABLE producenci
    ADD CHECK ( czy_spasowal IN (
        'n',
        't'
    ) );

COMMENT ON COLUMN producenci.nazwa_producenta IS
    'Nazwa identyfikujaca producenta zgodna z nazwa konta w aplikacji ApEx.';

COMMENT ON COLUMN producenci.fundusze IS
    'Aktualne fundusze jakimi dysponuje producent.';

COMMENT ON COLUMN producenci.czy_spasowal IS
    'Flaga oznaczajaca czy producent (gracz) spasowal, to znaczy czy wykonal wszystkie zaplanowane w danej rundzie ruchy i jest gotow do rozpoczecia nowej rundy.
''n'' - NIE
''t'' - TAK'
    ;

ALTER TABLE producenci ADD CONSTRAINT producenci_pk PRIMARY KEY ( id_producenta );

ALTER TABLE producenci ADD CONSTRAINT producenci_nazwa_producenta_un UNIQUE ( nazwa_producenta );

CREATE TABLE produkcje (
    id_produkcji   NUMBER(12) NOT NULL,
    wolumen        NUMBER(10) NOT NULL,
    numer_rundy    NUMBER(5) NOT NULL,
    id_marki       NUMBER(6) NOT NULL
);

CREATE INDEX produkcje_nry_rund_fk_idx ON
    produkcje (
        numer_rundy
    ASC );

CREATE INDEX produkcje_marki_fk_idx ON
    produkcje (
        id_marki
    ASC );

ALTER TABLE produkcje ADD CONSTRAINT produkcje_pk PRIMARY KEY ( id_produkcji );

CREATE TABLE przynaleznosci_do_grup (
    id_konsumenta          NUMBER(10) NOT NULL,
    id_grupy_konsumentow   NUMBER(5) NOT NULL
);

CREATE INDEX przyn_do_grup_gr_kons_fk_idx ON
    przynaleznosci_do_grup (
        id_grupy_konsumentow
    ASC );

ALTER TABLE przynaleznosci_do_grup ADD CONSTRAINT przynaleznosci_do_grup_pk PRIMARY KEY ( id_konsumenta,
                                                                                          id_grupy_konsumentow );

CREATE TABLE ustawienia_poczatkowe (
    numer_zestawu                    NUMBER(2) NOT NULL,
    czy_aktywna                      CHAR(1 CHAR) DEFAULT 'n' NOT NULL,
    warunek_zakonczenia_rundy        CHAR(1 CHAR) DEFAULT 'r' NOT NULL,
    czas_rundy                       NUMBER(6),
    liczba_rund                      NUMBER(5),
    poczatkowe_fundusze              NUMBER(8) NOT NULL,
    koszt_utworzenia_marki           NUMBER(8) NOT NULL,
    ref_koszt_bazowy_market          NUMBER(8) NOT NULL,
    ref_koszt_per_st_intens          NUMBER(8) NOT NULL,
    wplyw_marketingu_producenta      NUMBER(3, 2) DEFAULT 0.4 NOT NULL,
    liczba_konsumentow               NUMBER(10) NOT NULL,
    wym_max_cena                     NUMBER(10) NOT NULL,
    wym_min_cena                     NUMBER(10) NOT NULL,
    wym_kons_max_roznica_cena        NUMBER(10) NOT NULL,
    wym_kons_min_roznica_cena        NUMBER(10) NOT NULL,
    wym_kons_max_roznica_jakosc      NUMBER(2) NOT NULL,
    wym_kons_min_roznica_jakosc      NUMBER(2) NOT NULL,
    wym_kons_max_roznica_his_zak     NUMBER(3, 2) DEFAULT 0.8 NOT NULL,
    wym_kons_min_roznica_his_zak     NUMBER(3, 2) DEFAULT 0.2 NOT NULL,
    wym_kons_max_roznica_marketing   NUMBER(3) NOT NULL,
    wym_kons_min_roznica_marketing   NUMBER(2) NOT NULL,
    ref_sposob_nalicz_koszt_mag      CHAR(1 CHAR) DEFAULT 'm' NOT NULL,
    ref_wielkosc_powierzchni_mag     NUMBER(12),
    ref_koszt_mag_szt_lub_magazynu   NUMBER(15) NOT NULL,
    ref_upust_za_kolejny_magazyn     NUMBER(2),
    czy_jakosci_marek_domyslne       CHAR(1 CHAR) DEFAULT 't' NOT NULL,
    opis                             VARCHAR2(200 CHAR)
);

ALTER TABLE ustawienia_poczatkowe
    ADD CHECK ( czy_aktywna IN (
        'a',
        'n'
    ) );

ALTER TABLE ustawienia_poczatkowe
    ADD CHECK ( warunek_zakonczenia_rundy IN (
        'c',
        'p',
        'r'
    ) );

ALTER TABLE ustawienia_poczatkowe ADD CHECK ( wplyw_marketingu_producenta BETWEEN 0 AND 1 );

ALTER TABLE ustawienia_poczatkowe
    ADD CHECK ( wym_kons_max_roznica_his_zak BETWEEN 0.1 AND 1 );

ALTER TABLE ustawienia_poczatkowe
    ADD CHECK ( wym_kons_min_roznica_his_zak BETWEEN 0.1 AND 1 );

ALTER TABLE ustawienia_poczatkowe ADD CHECK ( wym_kons_max_roznica_marketing BETWEEN 10 AND 100 );

ALTER TABLE ustawienia_poczatkowe
    ADD CHECK ( ref_sposob_nalicz_koszt_mag IN (
        'l',
        'm'
    ) );

ALTER TABLE ustawienia_poczatkowe
    ADD CHECK ( czy_jakosci_marek_domyslne IN (
        'n',
        't'
    ) );

COMMENT ON COLUMN ustawienia_poczatkowe.czy_aktywna IS
    '''a'' - aktywny
''n'' - nieaktywny
Ustawiona flaga aktywnosci oznacza, ze z tego zestawu beda pobierane ustawienia na rzecz rozgrywki; tylko jednen zestaw ustawien poczatkowych moze miec ustawiona te flage. Jesli nie ma zaden, wowczas gra pobiera dane z zestawu o najmniejszym numerze'
    ;

COMMENT ON COLUMN ustawienia_poczatkowe.warunek_zakonczenia_rundy IS
    'Ten parametr moze przyjac jedna z trzech nastepujacych wartosci:
''p'' - wszyscy gracze wykonali swoje dzialania i spasowali
''c'' - uplunal okreslony czas
''r'' - nowa  runda jest rozpoczynana  recznie przez prowadzacego gre'
    ;

COMMENT ON COLUMN ustawienia_poczatkowe.czas_rundy IS
    'Czas trwania rundy w minutach. Ma znaczenie tylko jesli poprzedni parametr zostal ustawiony jako ''c'', w pozostalych przypadkach moze byc null.'
    ;

COMMENT ON COLUMN ustawienia_poczatkowe.liczba_rund IS
    'Ile rund ma trwac jedna rozgrywka. Jesli parametr jest ustawiony jako null, wowczas liczba rund nie jest ograniczona.';

COMMENT ON COLUMN ustawienia_poczatkowe.poczatkowe_fundusze IS
    'Fundusze jakie na start otrzymuje kazdy gracz. Wartosc reprezentuje setne czesci waluty (grosze, centy itp.).';

COMMENT ON COLUMN ustawienia_poczatkowe.koszt_utworzenia_marki IS
    'Aktualny koszt wprowadzenia nowej marki na rynek.';

COMMENT ON COLUMN ustawienia_poczatkowe.ref_koszt_bazowy_market IS
    'Referencyjny koszt bazowy marketingu przypisywany na starcie kazdemu graczowi. W trakcie rozgrywki moze ulec zmianie indywidualnie dla kazdego z graczy.'
    ;

COMMENT ON COLUMN ustawienia_poczatkowe.ref_koszt_per_st_intens IS
    'Referencyjny koszt za kazdy stopien (punkt) intensywnosci marketingu przypisywany na starcie kazdemu graczowi. W trakcie rozgrywki moze ulec zmianie indywidualnie dla kazdego z graczy.'
    ;

COMMENT ON COLUMN ustawienia_poczatkowe.wplyw_marketingu_producenta IS
    'Okresla jaka czesc calego marketingu, na podstawie ktorego konsument podejmuje decyzje, stanowi srednia z marketingu wszystkich marek producenta.'
    ;

COMMENT ON COLUMN ustawienia_poczatkowe.liczba_konsumentow IS
    'Ilu konsumentow zostanie wygenerowanych na potrzeby nowej rozgrywki. Zmiana tego parametru w trakcie trwania rozgrywki nie wplywa na zmiane liczbnosci juz wygenerowanego zbioru konsumentow.'
    ;

COMMENT ON COLUMN ustawienia_poczatkowe.wym_max_cena IS
    'Wymagania konsumenta - maksymalna mozliwa wartosc poziomu rezerwacji konsumenta w kryterium ceny.';

COMMENT ON COLUMN ustawienia_poczatkowe.wym_min_cena IS
    'Wymagania konsumenta - mnimalna mozliwa wartosc poziomu aspiracji konsumenta w kryterium ceny.';

COMMENT ON COLUMN ustawienia_poczatkowe.wym_kons_max_roznica_cena IS
    'Wymagania konsumenta - mozliwa maksymalna roznica miedzy poziomem rezerwacji a poziomiem aspiracji konsumenta w kryterium ceny.'
    ;

COMMENT ON COLUMN ustawienia_poczatkowe.wym_kons_min_roznica_cena IS
    'Wymagania konsumenta - mozliwa minimalna roznica miedzy poziomem rezerwacji a poziomiem aspiracji konsumenta w kryterium ceny.'
    ;

COMMENT ON COLUMN ustawienia_poczatkowe.wym_kons_max_roznica_jakosc IS
    'Wymagania konsumenta - mozliwa maksymalna roznica miedzy poziomem aspiracji a poziomiem rezerwacji konsumenta w kryterium jakosci.'
    ;

COMMENT ON COLUMN ustawienia_poczatkowe.wym_kons_min_roznica_jakosc IS
    'Wymagania konsumenta - mozliwa minimalna roznica miedzy poziomem aspiracji a poziomiem rezerwacji konsumenta w kryterium jakosci.'
    ;

COMMENT ON COLUMN ustawienia_poczatkowe.wym_kons_max_roznica_his_zak IS
    'Wymagania konsumenta - mozliwa maksymalna roznica miedzy poziomem aspiracji a poziomiem rezerwacji konsumenta w kryterium przywiazania do marki realizowanym jako historia zakupow konusmenta.'
    ;

COMMENT ON COLUMN ustawienia_poczatkowe.wym_kons_min_roznica_his_zak IS
    'Wymagania konsumenta - mozliwa minimalna roznica miedzy poziomem aspiracji a poziomiem rezerwacji konsumenta w kryterium przywiazania do marki realizowanym jako historia zakupow konusmenta.'
    ;

COMMENT ON COLUMN ustawienia_poczatkowe.wym_kons_max_roznica_marketing IS
    'Wymagania konsumenta - mozliwa maksymalna roznica miedzy poziomem aspiracji a poziomiem rezerwacji konsumenta w kryterium marketingu.'
    ;

COMMENT ON COLUMN ustawienia_poczatkowe.wym_kons_min_roznica_marketing IS
    'Wymagania konsumenta - mozliwa maksymalna roznica miedzy poziomem aspiracji a poziomiem rezerwacji konsumenta w kryterium marketingu.'
    ;

COMMENT ON COLUMN ustawienia_poczatkowe.ref_sposob_nalicz_koszt_mag IS
    'Referencyjny sposob naliczania kosztow magazynowania. W trakcie trwania gry wartosc ta moze byc zmieniana dla kazdego producenta indywidualnie w tabeli KOSZTY MAGAZYNOWANIA.
''l'' - liniowy
''m'' - producent placi za magazyn o okreslonej wielkosci wyrazonej w liczbie sztuk produktu, niezaleznie od stopnia zapelnienia'
    ;

COMMENT ON COLUMN ustawienia_poczatkowe.ref_wielkosc_powierzchni_mag IS
    'Referencyjna wielkosc powierzchni magazynowej, ktora okresla  ile maksymalnie sztuk towaru zmiesci sie na powierzchni magazynowej, za ktora bedzie musial zaplacic producent. W trakcie trwania gry wartosc ta moze byc zmieniana dla kazdego producenta indywidualnie w tabeli KOSZTY MAGAZYNOWANIA.'
    ;

COMMENT ON COLUMN ustawienia_poczatkowe.ref_koszt_mag_szt_lub_magazynu IS
    'Referencyjny koszt zmagazynowania jednej sztuki (jesli obowiazuje liniowe naliczanie oplat) lub koszt wynajecia powierzchni magazynowej (jesli obowiazuje naliczanie oplat zwiazane z powierzchnia magazynowa). W trakcie trwania gry wartosc ta moze byc zmieniana dla kazdego producenta indywidualnie w tabeli KOSZTY MAGAZYNOWANIA.'
    ;

COMMENT ON COLUMN ustawienia_poczatkowe.ref_upust_za_kolejny_magazyn IS
    'Referencyjny upust (w %) jaki dostanie producent za kazda kolejna (poza pierwsza) wynajeta przestrzen magazynowa. W trakcie trwania gry wartosc ta moze byc zmieniana dla kazdego producenta indywidualnie w tabeli KOSZTY MAGAZYNOWANIA.'
    ;

COMMENT ON COLUMN ustawienia_poczatkowe.czy_jakosci_marek_domyslne IS
    '''t'' - TAK
''n'' - NIE
Jesli ten parametr ma wartosc ''t'', wowczas na poczatku nowej gry wszystkie poziomy jakosci zapisane w tabeli JAKOSCI MAREK sa usuwane i generowany jest nowy, domyslny zestaw poziomow jakosci.'
    ;

ALTER TABLE ustawienia_poczatkowe ADD CONSTRAINT ustawienia_poczatkowe_pk PRIMARY KEY ( numer_zestawu );

CREATE TABLE zakupy_konsumentow (
    numer_rundy     NUMBER(5) NOT NULL,
    id_konsumenta   NUMBER(10) NOT NULL,
    id_marki        NUMBER(6)
);

CREATE INDEX zakupy_kons_nry_rund_fk_idx ON
    zakupy_konsumentow (
        numer_rundy
    ASC );

CREATE INDEX zakupy_kons_marki_fk_idx ON
    zakupy_konsumentow (
        id_marki
    ASC );

ALTER TABLE zakupy_konsumentow ADD CONSTRAINT zakupy_konsumentow_pk PRIMARY KEY ( id_konsumenta,
                                                                                  numer_rundy );

ALTER TABLE badania_rynku
    ADD CONSTRAINT badania_rynku_gry_kons_fk FOREIGN KEY ( id_grupy_konsumentow )
        REFERENCES grupy_konsumentow ( id_grupy_konsumentow )
            ON DELETE CASCADE;

ALTER TABLE badania_rynku
    ADD CONSTRAINT badania_rynku_marki_fk FOREIGN KEY ( id_marki )
        REFERENCES marki ( id_marki );

ALTER TABLE badania_rynku
    ADD CONSTRAINT badania_rynku_numery_rund_fk FOREIGN KEY ( numer_rundy )
        REFERENCES numery_rund ( numer_rundy )
            ON DELETE CASCADE;

ALTER TABLE dostepy_producentow_his_zakup
    ADD CONSTRAINT dost_prod_badania_rynku_fk FOREIGN KEY ( id_badania_rynku )
        REFERENCES badania_rynku ( id_badania_rynku )
            ON DELETE CASCADE;

ALTER TABLE dostepy_producentow_his_zakup
    ADD CONSTRAINT dost_prod_zakupy_kons_fk FOREIGN KEY ( id_konsumenta,
                                                          numer_rundy )
        REFERENCES zakupy_konsumentow ( id_konsumenta,
                                        numer_rundy )
            ON DELETE CASCADE;

ALTER TABLE historie_cen
    ADD CONSTRAINT historie_cen_marki_fk FOREIGN KEY ( id_marki )
        REFERENCES marki ( id_marki )
            ON DELETE CASCADE;

ALTER TABLE historie_cen
    ADD CONSTRAINT historie_cen_numery_rund_fk FOREIGN KEY ( numer_rundy )
        REFERENCES numery_rund ( numer_rundy )
            ON DELETE CASCADE;

ALTER TABLE koszty_magazynowania
    ADD CONSTRAINT koszty_magazyn_nry_rund_fk FOREIGN KEY ( numer_rundy )
        REFERENCES numery_rund ( numer_rundy )
            ON DELETE CASCADE;

ALTER TABLE koszty_magazynowania
    ADD CONSTRAINT koszty_magazyn_producenci_fk FOREIGN KEY ( id_producenta )
        REFERENCES producenci ( id_producenta )
            ON DELETE CASCADE;

ALTER TABLE koszty_marketingu
    ADD CONSTRAINT koszty_marketingu_nry_rund_fk FOREIGN KEY ( numer_rundy )
        REFERENCES numery_rund ( numer_rundy );

ALTER TABLE koszty_marketingu
    ADD CONSTRAINT koszty_marketingu_prod_fk FOREIGN KEY ( id_producenta )
        REFERENCES producenci ( id_producenta );

ALTER TABLE koszty_produkcji_produktow
    ADD CONSTRAINT koszty_produkcji_marki_fk FOREIGN KEY ( id_marki )
        REFERENCES marki ( id_marki )
            ON DELETE CASCADE;

ALTER TABLE koszty_produkcji_produktow
    ADD CONSTRAINT koszty_produkcji_nry_rund_fk FOREIGN KEY ( numer_rundy )
        REFERENCES numery_rund ( numer_rundy )
            ON DELETE CASCADE;

ALTER TABLE magazynowania
    ADD CONSTRAINT magazynowania_marki_fk FOREIGN KEY ( id_marki )
        REFERENCES marki ( id_marki )
            ON DELETE CASCADE;

ALTER TABLE magazynowania
    ADD CONSTRAINT magazynowania_numery_rund_fk FOREIGN KEY ( numer_rundy )
        REFERENCES numery_rund ( numer_rundy )
            ON DELETE CASCADE;

ALTER TABLE marketingi
    ADD CONSTRAINT marketingi_marki_fk FOREIGN KEY ( id_marki )
        REFERENCES marki ( id_marki )
            ON DELETE CASCADE;

ALTER TABLE marketingi
    ADD CONSTRAINT marketingi_numery_rund_fk FOREIGN KEY ( numer_rundy )
        REFERENCES numery_rund ( numer_rundy )
            ON DELETE CASCADE;

ALTER TABLE marki
    ADD CONSTRAINT marki_jakosci_marek_fk FOREIGN KEY ( jakosc_marki )
        REFERENCES jakosci_marek ( jakosc_marki )
            ON DELETE CASCADE;

ALTER TABLE marki
    ADD CONSTRAINT marki_producenci_fk FOREIGN KEY ( id_producenta )
        REFERENCES producenci ( id_producenta )
            ON DELETE CASCADE;

ALTER TABLE oceny_marek
    ADD CONSTRAINT oceny_marek_badania_rynku_fk FOREIGN KEY ( id_badania_rynku )
        REFERENCES badania_rynku ( id_badania_rynku )
            ON DELETE CASCADE;

ALTER TABLE oceny_marek
    ADD CONSTRAINT oceny_marek_konsumenci_fk FOREIGN KEY ( id_konsumenta )
        REFERENCES konsumenci ( id_konsumenta )
            ON DELETE CASCADE;

ALTER TABLE produkcje
    ADD CONSTRAINT produkcje_marki_fk FOREIGN KEY ( id_marki )
        REFERENCES marki ( id_marki )
            ON DELETE CASCADE;

ALTER TABLE produkcje
    ADD CONSTRAINT produkcje_numery_rund_fk FOREIGN KEY ( numer_rundy )
        REFERENCES numery_rund ( numer_rundy )
            ON DELETE CASCADE;

ALTER TABLE przynaleznosci_do_grup
    ADD CONSTRAINT przyn_do_grup_gry_kons_fk FOREIGN KEY ( id_grupy_konsumentow )
        REFERENCES grupy_konsumentow ( id_grupy_konsumentow )
            ON DELETE CASCADE;

ALTER TABLE przynaleznosci_do_grup
    ADD CONSTRAINT przyn_do_grup_konsumenci_fk FOREIGN KEY ( id_konsumenta )
        REFERENCES konsumenci ( id_konsumenta )
            ON DELETE CASCADE;

ALTER TABLE zakupy_konsumentow
    ADD CONSTRAINT zakupy_konsumentow_kons_fk FOREIGN KEY ( id_konsumenta )
        REFERENCES konsumenci ( id_konsumenta )
            ON DELETE CASCADE;

ALTER TABLE zakupy_konsumentow
    ADD CONSTRAINT zakupy_konsumentow_marki_fk FOREIGN KEY ( id_marki )
        REFERENCES marki ( id_marki )
            ON DELETE CASCADE;

ALTER TABLE zakupy_konsumentow
    ADD CONSTRAINT zakupy_konsumentow_nry_rund_fk FOREIGN KEY ( numer_rundy )
        REFERENCES numery_rund ( numer_rundy )
            ON DELETE CASCADE;

CREATE OR REPLACE TRIGGER fkntm_koszty_magazynowania BEFORE
    UPDATE OF id_producenta, numer_rundy ON koszty_magazynowania
    FOR EACH ROW
BEGIN
    IF :new.id_producenta != :old.id_producenta or :new.numer_rundy != :old.numer_rundy then
        raise_application_error(-20225, 'Non Transferable FK constraint  on table KOSZTY_MAGAZYNOWANIA is violated');
    end if;
END;
/

CREATE OR REPLACE TRIGGER fkntm_koszty_marketingu BEFORE
    UPDATE OF numer_rundy, id_producenta ON koszty_marketingu
    FOR EACH ROW
BEGIN
    IF :new.id_producenta != :old.id_producenta or :new.numer_rundy != :old.numer_rundy then
        raise_application_error(-20225, 'Non Transferable FK constraint  on table KOSZTY_MARKETINGU is violated');
    end if;
END;
/

CREATE OR REPLACE TRIGGER fkntm_koszty_produkcji_produkt BEFORE
    UPDATE OF numer_rundy, id_marki ON koszty_produkcji_produktow
    FOR EACH ROW
BEGIN
    IF :new.id_marki != :old.id_marki or :new.numer_rundy != :old.numer_rundy then
        raise_application_error(-20225, 'Non Transferable FK constraint  on table KOSZTY_PRODUKCJI_PRODUKTOW is violated');
    end if;
END;
/

CREATE OR REPLACE TRIGGER fkntm_badania_rynku BEFORE
    UPDATE OF id_marki, numer_rundy, id_grupy_konsumentow ON badania_rynku
    FOR EACH ROW
BEGIN
    IF :new.id_marki != :old.id_marki or :new.numer_rundy != :old.numer_rundy or :new.id_grupy_konsumentow  != :old.id_grupy_konsumentow then
        raise_application_error(-20225, 'Non Transferable FK constraint  on table BADANIA_RYNKU is violated');
    end if;
END;
/

CREATE OR REPLACE TRIGGER fkntm_dostepy_producentow_his_ BEFORE
    UPDATE OF id_badania_rynku, id_konsumenta, numer_rundy ON dostepy_producentow_his_zakup
    FOR EACH ROW
BEGIN
    IF :new.id_badania_rynku != :old.id_badania_rynku or :new.id_konsumenta != :old.id_konsumenta or :new.numer_rundy != :old.numer_rundy then
        raise_application_error(-20225, 'Non Transferable FK constraint  on table DOSTEPY_PRODUCENTOW_HIS_ZAKUP is violated');
    end if;
END;
/

CREATE OR REPLACE TRIGGER fkntm_historie_cen BEFORE
    UPDATE OF id_marki, numer_rundy ON historie_cen
    FOR EACH ROW
BEGIN
    IF :new.id_marki != :old.id_marki or :new.numer_rundy != :old.numer_rundy then
        raise_application_error(-20225, 'Non Transferable FK constraint  on table HISTORIE_CEN is violated');
    end if;
END;
/

CREATE OR REPLACE TRIGGER fkntm_magazynowania BEFORE
    UPDATE OF numer_rundy, id_marki ON magazynowania
    FOR EACH ROW
BEGIN
    IF :new.id_marki != :old.id_marki or :new.numer_rundy != :old.numer_rundy then
        raise_application_error(-20225, 'Non Transferable FK constraint  on table MAGAZYNOWANIA is violated');
    end if;
END;
/

CREATE OR REPLACE TRIGGER fkntm_marketingi BEFORE
    UPDATE OF id_marki, numer_rundy ON marketingi
    FOR EACH ROW
BEGIN
    IF :new.id_marki != :old.id_marki or :new.numer_rundy != :old.numer_rundy then
        raise_application_error(-20225, 'Non Transferable FK constraint  on table MARKETINGI is violated');
    end if;
END;
/

CREATE OR REPLACE TRIGGER fkntm_marki BEFORE
    UPDATE OF id_producenta, jakosc_marki ON marki
    FOR EACH ROW
BEGIN
    if :new.id_producenta != :old.id_producenta or :new.jakosc_marki != :old.jakosc_marki then
        raise_application_error(-20225, 'Non Transferable FK constraint  on table MARKI is violated');
    end if;
END;
/

CREATE OR REPLACE TRIGGER fkntm_oceny_marek BEFORE
    UPDATE OF id_badania_rynku, id_konsumenta ON oceny_marek
    FOR EACH ROW
BEGIN
    IF :new.id_badania_rynku != :old.id_badania_rynku or :new.id_konsumenta != :old.id_konsumenta then
        raise_application_error(-20225, 'Non Transferable FK constraint  on table OCENY_MAREK is violated');
    end if;
END;
/

CREATE OR REPLACE TRIGGER fkntm_produkcje BEFORE
    UPDATE OF numer_rundy, id_marki ON produkcje
    FOR EACH ROW
BEGIN
    IF  :new.id_marki != :old.id_marki or :new.numer_rundy != :old.numer_rundy then
        raise_application_error(-20225, 'Non Transferable FK constraint  on table PRODUKCJE is violated');
    END IF;
END;
/

CREATE OR REPLACE TRIGGER fkntm_przynaleznosci_do_grup BEFORE
    UPDATE OF id_konsumenta, id_grupy_konsumentow ON przynaleznosci_do_grup
    for each row
BEGIN
    if :new.id_konsumenta != :old.id_konsumenta or :new.id_grupy_konsumentow != :old.id_grupy_konsumentow then
        raise_application_error(-20225, 'Non Transferable FK constraint  on table PRZYNALEZNOSCI_DO_GRUP is violated');
    end if;
END;
/

CREATE OR REPLACE TRIGGER fknto_zakupy_konsumentow BEFORE
    UPDATE OF id_marki ON zakupy_konsumentow
    FOR EACH ROW
BEGIN
    IF :old.id_marki != :new.id_marki THEN
        raise_application_error(-20225, 'Non Transferable FK constraint ZAKUPY_KONSUMENTOW_MARKI_FK on table ZAKUPY_KONSUMENTOW is violated'
        );
    END IF;
END;
/

CREATE OR REPLACE TRIGGER fkntm_zakupy_konsumentow BEFORE
    UPDATE OF id_konsumenta, numer_rundy ON zakupy_konsumentow
FOR EACH ROW
BEGIN
    if :new.id_konsumenta != :old.id_konsumenta or :new.numer_rundy != :old.numer_rundy then
        raise_application_error(-20225, 'Non Transferable FK constraint  on table ZAKUPY_KONSUMENTOW is violated');
    end if;
END;
/


-- Oracle SQL Developer Data Modeler Summary Report: 
-- 
-- CREATE TABLE                            19
-- CREATE INDEX                            19
-- ALTER TABLE                             92
-- CREATE VIEW                              0
-- ALTER VIEW                               0
-- CREATE PACKAGE                           0
-- CREATE PACKAGE BODY                      0
-- CREATE PROCEDURE                         0
-- CREATE FUNCTION                          0
-- CREATE TRIGGER                          14
-- ALTER TRIGGER                            0
-- CREATE COLLECTION TYPE                   0
-- CREATE STRUCTURED TYPE                   0
-- CREATE STRUCTURED TYPE BODY              0
-- CREATE CLUSTER                           0
-- CREATE CONTEXT                           0
-- CREATE DATABASE                          0
-- CREATE DIMENSION                         0
-- CREATE DIRECTORY                         0
-- CREATE DISK GROUP                        0
-- CREATE ROLE                              0
-- CREATE ROLLBACK SEGMENT                  0
-- CREATE SEQUENCE                          0
-- CREATE MATERIALIZED VIEW                 0
-- CREATE MATERIALIZED VIEW LOG             0
-- CREATE SYNONYM                           0
-- CREATE TABLESPACE                        0
-- CREATE USER                              0
-- 
-- DROP TABLESPACE                          0
-- DROP DATABASE                            0
-- 
-- REDACTION POLICY                         0
-- 
-- ORDS DROP SCHEMA                         0
-- ORDS ENABLE SCHEMA                       0
-- ORDS ENABLE OBJECT                       0
-- 
-- ERRORS                                   0
-- WARNINGS                                 0
